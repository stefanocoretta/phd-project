---
title: "Spline plotting and SSANOVA"
author: "Stefano Coretta"
date: \today
output: 
  pdf_document: 
    fig_caption: yes
    fig_height: 3.5
    fig_width: 5
    latex_engine: xelatex
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath("../../"))
library(readr)
library(purrr)
library(tidyr)
library(dplyr)
library(ggplot2)
theme_set(theme_bw())
library(gss)
library(stringr)
library(lme4)
library(afex)
library(effects)
```

# Data import

Before importing the data, we need to specify the column names for the data set header, since the raw data does not have a header. The number of splines is always 42 (saved as `num.splines`). `first.columns` is a factor containing the names of columns that are not the splines coordinates columns. Finally, we can concatenate `first.columns` with the names of the splines coordinates which is generated by the `paste0` function in the format `X_1, Y_1, X_2, Y_2, X_n, ...` (the underscore `_` will be useful for separating the axis from the fan number).

```{r col-names}
num.splines <- 42
first.columns <- c(
    "speaker",
    "seconds",
    "rec.date",
    "prompt",
    "label",
    "TT.displacement.sm",
    "TT.velocity",
    "TT.velocity.abs",
    "TD.displacement.sm",
    "TD.velocity",
    "TD.velocity.abs"
    )
columns <- c(first.columns,
             paste0(rep(c("X", "Y"), num.splines),
                    "_",
                    rep(1:num.splines, each = 2)
                    )
             )
```

We can now read in the file.

```{r read}
splines.raw <- list.files(path = "./pilot/results",
                   pattern = "*-aaa.csv",
                   full.names = TRUE) %>%
    map_df(~read_tsv(., col_names = columns, na = "*"))

rm(num.splines, first.columns, columns)

languages <- read_csv("./pilot/stimuli/languages.csv")
words <- read_csv("./pilot/stimuli/nonce.csv")
```

The following code applies tidy formatting to the data frame. It uses functions from the `tidyr` library.

```{r tidy}
splines <- splines.raw %>%
    gather(spline, coordinate, matches("[XY]_")) %>%
    separate(spline, c("axis", "fan"), convert = TRUE) %>%
    spread(axis, coordinate) %>%
    mutate(word = word(prompt, 2)) %>%
    left_join(y = languages) %>%
    left_join(y = words) %>%
    mutate_if(is.character, as.factor)

splines.it <- filter(splines, language == "italian")
splines.pl <- filter(splines, language == "polish")
```

# Some plotting

We can finally plot splines.

```{r velar, eval=FALSE}
filter(splines, label == "max_TD") %>%
ggplot(aes(x = X, y = Y, colour = c2phonation, group = word)) +
    geom_smooth(method = "loess", se = FALSE) +
    coord_fixed(ratio = 1) +
    facet_grid(vowel ~ language)
```

```{r coronal, eval=FALSE}
filter(splines, label == "max_TT") %>%
ggplot(aes(x = X, y = Y, colour = c2phonation, group = word)) +
    geom_smooth(method = "loess", se = FALSE) +
    coord_fixed(ratio = 1) +
    facet_grid(vowel ~ language)
```

# SSANOVA

```{r ssanovaTongue}
ssanovaTongue <- function(splines) {
    model <- ssanova(Y ~ c2phonation + X + c2phonation:X, data = splines)
    
    predicted <- expand.grid(X = seq(min(splines$X, na.rm = TRUE),
                                     max(splines$X, na.rm = TRUE),
                                     length = 100),
                             Y = seq(min(splines$Y, na.rm = TRUE),
                                     max(splines$Y, na.rm = TRUE),
                                     length = 100),
                             c2phonation = c("voiced", "voiceless")
    )
    
    predicted$splines.fit <- predict(model, predicted, se = T)$fit
    predicted$splines.SE <- predict(model, predicted, se = T)$se.fit
    
    return(predicted)
}
```

```{r ssanova-it}
splines.cor.a <- filter(splines.it, vowel == "a", label == "max_TT")
ssanova.cor.a <- ssanovaTongue(splines.cor.a)

splines.cor.o <- filter(splines.it, vowel == "o", label == "max_TT")
ssanova.cor.o <- ssanovaTongue(splines.cor.a)

splines.cor.u <- filter(splines.it, vowel == "u", label == "max_TT")
ssanova.cor.u <- ssanovaTongue(splines.cor.u)


splines.vel.a <- filter(splines.it, vowel == "a", label == "max_TD")
ssanova.vel.a <- ssanovaTongue(splines.vel.a)

splines.vel.o <- filter(splines.it, vowel == "o", label == "max_TD")
ssanova.vel.o <- ssanovaTongue(splines.vel.a)

splines.vel.u <- filter(splines.it, vowel == "u", label == "max_TD")
ssanova.vel.u <- ssanovaTongue(splines.vel.u)
```


```{r ssanova-cor-plot-it}
ggplot(ssanova.cor.a, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.cor.o, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.cor.u, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )
```

```{r ssanova-vel-plot-it}
ggplot(ssanova.vel.a, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.vel.o, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.vel.u, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )
```

```{r ssanova-pl}
splines.cor.a <- filter(splines.pl, vowel == "a", label == "max_TT")
ssanova.cor.a <- ssanovaTongue(splines.cor.a)

splines.cor.o <- filter(splines.pl, vowel == "o", label == "max_TT")
ssanova.cor.o <- ssanovaTongue(splines.cor.a)

splines.cor.u <- filter(splines.pl, vowel == "u", label == "max_TT")
ssanova.cor.u <- ssanovaTongue(splines.cor.u)


splines.vel.a <- filter(splines.pl, vowel == "a", label == "max_TD")
ssanova.vel.a <- ssanovaTongue(splines.vel.a)

splines.vel.o <- filter(splines.pl, vowel == "o", label == "max_TD")
ssanova.vel.o <- ssanovaTongue(splines.vel.a)

splines.vel.u <- filter(splines.pl, vowel == "u", label == "max_TD")
ssanova.vel.u <- ssanovaTongue(splines.vel.u)
```


```{r ssanova-cor-plot-pl}
ggplot(ssanova.cor.a, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.cor.o, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.cor.u, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )
```

```{r ssanova-vel-plot-pl}
ggplot(ssanova.vel.a, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.vel.o, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(ssanova.vel.u, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )
```

# Consonantal gestures: target, maximum, release

Now we can create a separate data frame where the observasional unit is each word and the variables are the consonantal getures (target, maximum closure, release).

```{r gestures}
cons.gestures <- select(splines.raw, speaker:label) %>%
    mutate(word = word(prompt, 2)) %>%
    left_join(y = languages) %>%
    left_join(y = words) %>%
    separate(label, c("gesture", "tongue.area")) %>%
    spread(gesture, seconds) %>%
    mutate(nucleus = NOFF - NONS, deceleration = max - peak1) %>%
    mutate_if(is.character, as.factor)

gestures.it <- filter(cons.gestures, language == "italian")
gestures.pl <- filter(cons.gestures, language == "polish")
```

Let's plot the nucleus duration (NOFF - NONS) as a function of place of articulation, voicing of C2 (our target consonant in C1VC2V words), and language.

```{r nucleus-duration}
filter(cons.gestures, nucleus < 0.05) %>%
ggplot(aes(c2phonation, nucleus)) +
    facet_grid(.~language + c2place) +
    geom_violin() +
    geom_boxplot(width=0.1) +
    theme(strip.background = element_rect(fill = "black"),
          strip.text = element_text(color = "white", face = "bold")
          )
```

```{r nucleus-lmer-it}
nucleus.model.it <- lmer(
    nucleus ~
        c2phonation *
        vowel *
        c2place +
        (1|word) +
        (1|speaker),
    data = gestures.it
)

summary(nucleus.model.it)

mixed(
    nucleus ~
        c2phonation *
        vowel *
        c2place +
        (1|word) +
        (1|speaker),
    data = gestures.it
)
```

```{r nucleus-plot-it}
plot(allEffects(nucleus.model.it))
```


```{r nucleus-lmer-pl}
nucleus.model.pl <- lmer(
    nucleus ~
        c2phonation *
        vowel *
        c2place +
        (1|word),
    data = gestures.pl
)

summary(nucleus.model.pl)

mixed(
    nucleus ~
        c2phonation *
        vowel *
        c2place +
        (1|word),
    data = gestures.pl
)
```

```{r nucleus-plot-pl}
plot(allEffects(nucleus.model.pl))
```


```{r deceleration-duration}
ggplot(cons.gestures, aes(c2phonation, deceleration)) +
    facet_grid(.~language + c2place) +
    geom_violin() +
    geom_boxplot(width=0.1) +
    theme(strip.background = element_rect(fill = "black"),
          strip.text = element_text(color = "white", face = "bold")
          )
```


# Kinematics performance

I want to check how good the gesture function in AAA is performing. The following gives the number of missing values per speaker.

```{r performance-na}
cons.gestures %>%
    select(speaker, GOFF:NONS) %>%
    group_by(speaker) %>%
    summarise_each(funs(sum(is.na(.)))) %>%
    select(speaker, GONS, NONS, max, NOFF, GOFF)
```

This chunk instead reports the total number of values per speaker.

```{r performance-total}
cons.gestures %>%
    select(speaker, GOFF:NONS) %>%
    group_by(speaker) %>%
    summarise_each(funs(n())) %>%
    select(speaker, GONS, NONS, max, NOFF, GOFF)
```

By comparing the two tables, what emerges is that the GONS (Gesture Onset) is almost always missed, followed by GOFF (Gesture Offset). The NOFF (Nucleus Offset) detection, performs slighly better, while NONS and MAX are detected most of the times.

However, judging from the violin plots above, most values might be incorrect.






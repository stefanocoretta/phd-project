---
title: "Spline plotting and SSANOVA"
author: "Stefano Coretta"
date: "27/12/2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath("../"))
library(tidyr)
library(dplyr)
library(ggplot2)
theme_set(theme_bw())
library(gss)
library(stringr)
```

## Data import

Before importing the data, we need to specify the column names for the data set header, since the raw data does not have a header. The number of splines is always 42 (saved as `num.splines`). `first.columns` is a factor containing the names of columns that are not the splines coordinates columns. Finally, we can concatenate `first.columns` with the names of the splines coordinates which is generated by the `paste0` function in the format `X_1, Y_1, X_2, Y_2, X_n, ...` (the underscore `_` will be useful for separating the axis from the fan number).

```{r col-names}
num.splines = 42
first.columns <- c(
    "subject",
    "seconds",
    "rec.date",
    "prompt",
    "label",
    "TD.displacement",
    "TT.displacement",
    "TD.displacement.sm",
    "TD.velocity",
    "TD.velocity.abs",
    "TT.displacement.sm",
    "TT.velocity",
    "TT.velocity.abs"
    )
columns <- c(first.columns,
             paste0(rep(c("X", "Y"), num.splines),
                    "_",
                    rep(1:num.splines, each = 2)
                    )
             )
```

We can now read in the file.

```{r read}
raw.data <- read.delim("pilot/results/SC01-aaa.txt", header = FALSE,
                    na.string = '*', col.names = columns
                    )

rm(num.splines, first.columns, columns)

raw.data <- unique(raw.data)

stimuli <- read.csv("pilot/stimuli/nonce.csv")
```

The following code applies tidy formatting to the data frame. It uses functions from the `tidyr` library.

```{r tidy}
splines <- raw.data %>%
    gather(spline, coordinate, X_1:Y_42) %>%
    separate(spline, c("axis", "fan"), convert = TRUE) %>%
    spread(axis, coordinate) %>%
    mutate(word = as.factor(word(prompt, 2))) %>%
    left_join(y = stimuli)
```

## Some plotting

We can finally plot splines grouped by prompt.

```{r, eval=FALSE, include=FALSE}
ggplot(splines, aes(x = X, y = Y, group = word, colour = c2place)) + 
    geom_smooth(size = 0.5, alpha = 0.2) +
    coord_fixed(ratio = 1)
```

```{r velar, eval=FALSE, include=FALSE}
filter(splines, label == "target_TD") %>%
ggplot(aes(x = X, y = Y, colour = c2phonation)) +
    geom_smooth(method = "loess") +
    coord_fixed(ratio = 1)
```

```{r coronal, eval=FALSE, include=FALSE}
filter(splines, label == "target_TT") %>%
ggplot(aes(x = X, y = Y, colour = c2phonation)) +
    geom_smooth(method = "loess") +
    coord_fixed(ratio = 1)
```

## SSANOVA
```{r ssanova}
splines.cor <- filter(splines, label == "target_TT")
splines.cor.model <- ssanova(Y ~ c2phonation + X + c2phonation:X,
                             data = splines.cor)

splines.vel <- filter(splines, label == "target_TD")
splines.vel.model <- ssanova(Y ~ c2phonation + X + c2phonation:X,
                             data = splines.vel)

predicted.cor <- select(splines.cor, X:Y, c2phonation)
predicted.vel <- select(splines.vel, X:Y, c2phonation)

predicted.cor$splines.fit <- predict(splines.cor.model, predicted.cor, se = T)$fit
predicted.cor$splines.SE <- predict(splines.cor.model, predicted.cor,
                                    se = T)$se.fit

predicted.vel$splines.fit <- predict(splines.vel.model, predicted.vel,
                                     se = T)$fit
predicted.vel$splines.SE <- predict(splines.vel.model, predicted.vel,
                                    se = T)$se.fit
```

```{r ssanova-plot}
ggplot(predicted.cor, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )

ggplot(predicted.vel, aes(x = X, colour = c2phonation)) +
geom_line(aes(y = splines.fit)) +
geom_ribbon(aes(ymin = splines.fit - (1.96 * splines.SE),
                ymax = splines.fit + (1.96 * splines.SE),
                fill = c2phonation
                ),
            alpha = 0.5,
            color = "NA"
            )
```

## Consonantal gestures: target, maximum, release

Now we can create a separate data frame where the observasional unit is each word and the variables are the consonantal getures (target, maximum closure, release).

```{r gestures}
cons.gestures <- raw.data %>%
    select(subject:label) %>%
    separate(label, c("gesture", "tongue.area")) %>%
    spread(gesture, seconds) %>%
    select(subject:tongue.area, target, max, release) %>%
    mutate(closure = (release - target) * 1000) %>%
    mutate(word = as.factor(word(prompt, 2))) %>%
    left_join(y = stimuli)
```

Let's plot closure duration as a function of place of articulation and voicing of C2 (our target consonant in C1VC2V words).

```{r closure-duration}
ggplot(cons.gestures, aes(c2phonation, closure)) +
    facet_grid(.~c2place) +
    geom_violin() +
    geom_boxplot(width=0.1) +
    ylim(15, 60) +
    theme(strip.background = element_rect(fill = "black"),
          strip.text = element_text(color = "white", face = "bold")
          )
```









